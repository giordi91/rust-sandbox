#version 450

layout(set=0, binding=0)
uniform Uniforms {
    mat4 u_view_proj; 
    mat4 u_view_proj_inverse; 
};

layout(set = 1, binding = 0) uniform texture2D  depth_texture;
layout(set = 1, binding = 1) uniform sampler depth_sampler;
layout(set = 1, binding = 2, rgba32f) uniform image2D output_tex;

vec3 reconstructPosition(in vec2  uv, in float z, in mat4 InvVP)
{
  float x = uv.x * 2.0f - 1.0f;
  float y = (1.0 - uv.y) * 2.0f - 1.0f;
  vec4 position_s = vec4(x, y, z, 1.0f);
  vec4 position_v = InvVP* position_s;
  return position_v.xyz / position_v.w;
}


const int group_size = 8;
layout(local_size_x = group_size, local_size_y=group_size, local_size_z=1) in;

const int tile_border = 1;
const int tile_size = group_size + tile_border*2;
shared vec3[tile_size*tile_size] memory_tile;



uint flatten2D(uvec2 coord, uint width)
{
  return coord.x + coord.y * width;
}
uvec2 unflatten2D(uint idx, uint width)
{
  return uvec2(idx % width, idx / width);
}
void main() {

    int w = 1024;
    int h = 768;
    vec2 whf = vec2(w,h);

    uvec2 idx = gl_GlobalInvocationID.xy;

    //let us compute half pixel width 
    vec2 pixel_width =vec2(1.0,1.0)/ whf;
    vec2 pixel_half_width =pixel_width * 0.5f;
    vec2 pixel_coord = vec2(idx.x,idx.y);

    vec2 whoffset = vec2(idx.x,idx.y) + vec2(0.5);
    vec2 uv = pixel_coord* pixel_width + pixel_half_width;

    //load data in shared memory
const uvec2 tile_upperleft = gl_WorkGroupID.xy * group_size - tile_border;
for (uint t =gl_LocalInvocationIndex ; t < tile_size* tile_size; t += group_size* group_size)
{
  const uvec2 pixel = tile_upperleft + unflatten2D(t, tile_size);
  const vec2 uv = (pixel + 0.5f) * (1/whf);
  float depth = texture(sampler2D(depth_texture, depth_sampler), uv).r;
  const vec3 position = reconstructPosition(uv, depth, u_view_proj_inverse);
  memory_tile[t] = position;
}
    barrier();

    if((idx.x  <w) && (idx.y <h))
    {


const uint cross_idx[5] = {
		flatten2D(uvec2(tile_border) + gl_LocalInvocationID.xy, tile_size),				// 0: center
		flatten2D(uvec2(tile_border) + gl_LocalInvocationID.xy + uvec2(1, 0), tile_size),	// 1: right
		flatten2D(uvec2(tile_border) + gl_LocalInvocationID.xy + uvec2(-1, 0), tile_size),	// 2: left
		flatten2D(uvec2(tile_border) + gl_LocalInvocationID.xy + uvec2(0, 1), tile_size),	// 3: down
		flatten2D(uvec2(tile_border) + gl_LocalInvocationID.xy + uvec2(0, -1), tile_size),	// 4: up
	};

	const float center_Z = memory_tile[cross_idx[0]].z;

  float leftDelta = abs(memory_tile[cross_idx[2]].z - center_Z);
  float rightDelta = abs(memory_tile[cross_idx[1]].z - center_Z);
  float upDelta = abs(memory_tile[cross_idx[4]].z - center_Z);
  float downDelta = abs(memory_tile[cross_idx[3]].z - center_Z);
	const float hdelta = abs(memory_tile[cross_idx[1]].z - center_Z) < abs(memory_tile[cross_idx[2]].z - center_Z) ? rightDelta : leftDelta;
	const float vdelta = abs(memory_tile[cross_idx[3]].z - center_Z) < abs(memory_tile[cross_idx[4]].z - center_Z) ? downDelta: upDelta;

	const uint best_Z_horizontal = abs(memory_tile[cross_idx[1]].z - center_Z) < abs(memory_tile[cross_idx[2]].z - center_Z) ? 1 : 2;
	const uint best_Z_vertical = abs(memory_tile[cross_idx[3]].z - center_Z) < abs(memory_tile[cross_idx[4]].z - center_Z) ? 3 : 4;

	vec3 p1 = vec3(0,0,0);
	vec3 p2 = vec3(0,0,0);
	if (best_Z_horizontal == 1 && best_Z_vertical == 4)
	{
		p1 = vec3(memory_tile[cross_idx[1]].xy, memory_tile[cross_idx[1]].z);
		p2 = vec3(memory_tile[cross_idx[4]].xy, memory_tile[cross_idx[4]].z);

	}
	else if (best_Z_horizontal == 1 && best_Z_vertical == 3)
	{
		p1 = vec3(memory_tile[cross_idx[3]].xy, memory_tile[cross_idx[3]].z);
		p2 = vec3(memory_tile[cross_idx[1]].xy, memory_tile[cross_idx[1]].z);
	}
	else if (best_Z_horizontal == 2 && best_Z_vertical == 4)
	{
		p1 = vec3(memory_tile[cross_idx[4]].xy, memory_tile[cross_idx[4]].z);
		p2 = vec3(memory_tile[cross_idx[2]].xy, memory_tile[cross_idx[2]].z);

	}
	else if (best_Z_horizontal == 2 && best_Z_vertical == 3)
	{
		p1 = vec3(memory_tile[cross_idx[2]].xy, memory_tile[cross_idx[2]].z);
		p2 = vec3(memory_tile[cross_idx[3]].xy, memory_tile[cross_idx[3]].z);
	}

	const vec3 P = vec3(memory_tile[cross_idx[0]].xy, memory_tile[cross_idx[0]].z);
	const vec3 normal = normalize(cross(p1 - P, p2 - P));

      //load from memory and write out
      //vec3 loaded_depth = memory_tile[flatten2D(uvec2(tile_border,tile_border) + gl_LocalInvocationID.xy,tile_size)];
      imageStore(output_tex,ivec2(idx),vec4(normal,1.0f));
      //imageStore(output_tex,ivec2(idx),vec4(best_Z_horizontal == 1,best_Z_horizontal==2,0,1.0f));
      //float depth = texture(sampler2D(depth_texture, depth_sampler), uv).r;
      //imageStore(output_tex,ivec2(idx),vec4(depth*20,0,0,1.0f));

    }
}
