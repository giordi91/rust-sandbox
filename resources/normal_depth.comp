#version 450

layout(set=0, binding=0)
uniform Uniforms {
    mat4 u_view_proj; 
    mat4 u_view_proj_inverse; 
};

layout(set = 1, binding = 0) uniform texture2D  depth_texture;
layout(set = 1, binding = 1) uniform sampler depth_sampler;
layout(set = 1, binding = 2, rgba32f) uniform image2D output_tex;

vec3 reconstructPosition(in vec2  uv, in float z, in mat4 InvVP)
{
  float x = uv.x * 2.0f - 1.0f;
  float y = (1.0 - uv.y) * 2.0f - 1.0f;
  vec4 position_s = vec4(x, y, z, 1.0f);
  vec4 position_v = InvVP* position_s;
  return position_v.xyz / position_v.w;
}


layout(local_size_x = 16, local_size_y=16, local_size_z=1) in;

void main() {

    int w = 1024;
    int h = 768;
    vec2 whf = vec2(w,h);

    uvec2 idx = gl_GlobalInvocationID.xy;
    if((idx.x  <w) && (idx.y <h))
    {
      vec2 whoffset = vec2(idx.x,idx.y) + vec2(0.5);
      vec2 uv = whoffset / whf;
      
      whoffset = vec2(idx.x,idx.y) + vec2(1+ 0.5, 0.5);
      vec2 uv1 = whoffset / whf;
      whoffset = vec2(idx.x,idx.y) + vec2(0.5, 1+ 0.5);
      vec2 uv2 = whoffset / whf;
      
      float depth = texture(sampler2D(depth_texture, depth_sampler), uv).r;
      float depth1 = texture(sampler2D(depth_texture, depth_sampler), uv1).r;
      float depth2 = texture(sampler2D(depth_texture, depth_sampler), uv2).r;
      vec3 pos0 = reconstructPosition(uv,depth, u_view_proj_inverse); 
      vec3 pos1 = reconstructPosition(uv1,depth1, u_view_proj_inverse); 
      vec3 pos2 = reconstructPosition(uv2,depth2, u_view_proj_inverse); 
      vec3 normal =normalize(cross(pos2 - pos0, pos1 - pos0)) ;
      imageStore(output_tex,ivec2(idx),vec4(normal,1.0f));
      //imageStore(output_tex,ivec2(idx),vec4(depth2,0,0,1.0f));
    }
    //float depth = texture(sampler2D(depth_texture, depth_sampler), vec2(i_uv.x,i_uv.y)).r;
    //vec3 pos = reconstructPosition(i_uv,depth, u_view_proj_inverse); 
    //vec3 normal = normalize(cross(dFdx(pos), dFdy(pos)));
    //f_color = vec4(normal*0.5 + 0.5, 1.0);
}

/*
float2 uv0 = uv; // center
float2 uv1 = uv + float2(1, 0) / depth_dimensions; // right 
float2 uv2 = uv + float2(0, 1) / depth_dimensions; // top

float depth0 = texture_depth.SampleLevel(sampler_point_clamp, uv0, 0).r;
float depth1 = texture_depth.SampleLevel(sampler_point_clamp, uv1, 0).r;
float depth2 = texture_depth.SampleLevel(sampler_point_clamp, uv2, 0).r;

float3 P0 = reconstructPosition(uv0, depth0, InverseViewProjection);
float3 P1 = reconstructPosition(uv1, depth1, InverseViewProjection);
float3 P2 = reconstructPosition(uv2, depth2, InverseViewProjection);

float3 normal = normalize(cross(P2 - P0, P1 - P0));
*/
